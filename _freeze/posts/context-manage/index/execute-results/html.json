{
  "hash": "035ca4945f43de8075cdd8fab2b9fdf2",
  "result": {
    "markdown": "---\ntitle: Context managers (and why they're great)\nauthor: Johnny Breen\ndate: '2022-08-21'\nformat: html\ncategories:\n  - Python\n  - Programming\n---\n\nSo listen: to be a 'good' data analyst you don't need to know the ins and outs of software engineering. That would be a bit ridiculous.\n\nThat said, there are some software engineering 'best practices' that you should cherry-pick, if you will, and adopt into your workflow. And here comes my bold statement: I firmly believe that the idea of managing 'resources' is one such practice. I know, I know.. 'managing resources'? You may as well be a librarian.\n\nBut hear me out: you probably rely on tonnes of 'resources' to do your daily work without even realising it. What is your management strategy?\n\nSorry, I'm getting a bit ahead of myself here. Let's start with the most fundamental question: what do we mean by the word 'resource' exactly?\n\n# Resources explained\n\nSuppose you are writing a program which logs result of each operation to a `.txt` file on disk. Something like this (NB: use Python's native `logger` module to perform logging; not what follows!):\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef divide(x, y):\n  logger_file = open('app.log', 'a')\n  logger_file.write(f'Adding {x} and {y}...')\n  z = x / y\n  logger_file.close()\n  return z\n```\n:::\n\n\nYour computer can't just *write* this call to the file straight away. If you think about it, a few steps have to happen first:\n\n1.  If this file is hosted on another machine, your machine needs to gain access to the other machine (and potentially requires authentication)\n2.  Then, pending success on step 1, a connection to this file must be opened\n3.  Data is then written into the file via the connection channel\n4.  Finally, on the *attempt* of step 2 (regardless of success or failure), the connection to the file should be closed\n\nIn this context, your 'resource' is the logging file `app.log`; more formally, a 'resource' is a piece of software or hardware that is accessed and manipulated over a network. And, as you can see in the above, you need to *manage* this resource to avoid complications later down the line.\n\nWhat kind of complications am I speaking of? Most data analysts will be able to execute steps 1-3 successfully (because, well, they *have* to). But, again and again, I see far too many analysts fail to carry out step 4, which is the most important step.\n\n# How things can go wrong\n\nThe question you have to ask yourself here is what if the step in between `open()` and `close()` fails? In other words, what if `z = x / y` fails? Well, it will at some point because I have news for you: you can't divide by zero,\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntry:\n  divide(5, 0)\nexcept ZeroDivisionError as err:\n  print(err)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndivision by zero\n```\n:::\n:::\n\n\nThink about the control flow of our function `divide()` for a second: once it encounters an error, it will not close the file. Execution will terminate and the connection to our file will be left open. This is not an issue with a small number of connections but imagine that you are running this call, repeatedly, millions of times. There is a cost to maintaining millions of open connections: memory leakage.\n\nWe are using a contrived example to demonstrate the point here. This issue becomes much more pertinent when interacting with remote database systems.\n\n# How to fix it (there's more than one way)\n\nSo how can we improve this? Well, we need to make sure we close the file *whatever* happens. We can achieve this with the `try: … except: … else: … finally: …` syntax in Python:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef divide(x, y):\n  try:\n    logger_file = open('app.log', 'a')\n    logger_file.write(f'Adding {x} and {y}...')\n    z = x / y\n  except ZeroDivisionError as err:\n    raise err\n  finally:\n    logger_file.close()\n  return z\n```\n:::\n\n\nWith this syntax in place, any snippets which fall under the `finally` clause will always be executed regardless of success or failure.\n\nThe thing is: that's a lot of boilerplate to be adding to all of your functions and methods. There has to be a simpler way, surely? You're in luck: Python has a better way.\n\nYou can build your own context managers by either implementing a class with an `__enter__()` and `__exit()__` method or you can leverage the native Python module `contextlib` to achieve the same thing. I recommend you check out [this link](https://book.pythontips.com/en/latest/context_managers.html) for a thorough explanation of these resources.\n\n# Where I find this useful\n\nI manage database cursors (which are used toe execute queries against a database) using the context management protocol.\n\nYou can see this with a simple SQLite setup as below,\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom contextlib import contextmanager \n\nclass SQLite():\n\n    def __init__(self, database_path):\n        self.database_path = database_path\n        self._conn = sqlite3.connect(database_path, detect_types=sqlite3.PARSE_DECLTYPES)\n        self._conn.row_factory = sqlite3.Row\n        print('Connection opened.')\n\n    def __repr__(self):\n        return f'SQLite object (path: {self.database_path})'\n    \n    def __str__(self):\n        return f'SQLite object (path: {self.database_path})'\n    \n    def close(self):\n        self._conn.close()\n        print('Connection closed.')\n\n    @contextmanager\n    def cursor(self):\n        cursor = self._conn.cursor()\n        try:\n            yield cursor\n        except sqlite3.Error as err:\n            raise err\n        else:\n            self._conn.commit()     \n        finally:\n            cursor.close()\n```\n:::\n\n\nEverything before the `yield` keyword represents the acquisition of resources (i.e. the cursor). This is followed by the generation of the `cursor` object. Then, on exit of the method everything below the `yield` keyword is executed, including the closure of the cursor object.\n\nPretty neat!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}